#!/usr/bin sage
r"""Module containing the main parameter search function.

In our usage, ``sigma`` denotes the standard deviation :math:`\sigma` (if secret is normal form, also the secret standard devation), ``s`` denotes the Gaussian width parameter, :math:`s = \sigma \cdot \sqrt{2\pi}`, and :math:`\alpha = s / q`.
"""


from . import problem
from . import algorithms
from . import problem
import logging
import time
import bisect
import psutil
import sage.all
from sage.functions.log import exp, log
from sage.functions.other import ceil, sqrt, floor, binomial
from sage.rings.all import QQ, RR, ZZ, RealField, PowerSeriesRing, RDF
from sage.symbolic.all import pi, e
from sage.arith.all import random_prime as make_prime
from estimator import oo

## Logging ##
logger = logging.getLogger(__name__)
SEPARATOR = algorithms.SEPARATOR

# Utility # perhaps export if more is added in the future
def number_of_bits(v):
    if v == oo or v == -oo:
        return oo
    else:
        return ceil(log(abs(v), 2))


def unit_cost(*argv, **args):
    """
    Unit cost for given parameter set
    """
    return 0  # ensure that new ones are added at the end


class ParameterSet:
    """
    Helper class to order parameter sets in list
    """

    parameter_cost = unit_cost

    def __init__(self, parameters):
        self.parameters = parameters

    def __lt__(self, other):
        return ParameterSet.parameter_cost(
            *self.parameters
        ) < ParameterSet.parameter_cost(*other.parameters)


def generic_search(
    sec,
    initial_parameters,
    next_parameters,
    parameter_cost,
    parameter_problem,
    config: algorithms.Configuration = algorithms.Configuration(),
    scalar_parameters=False,
):
    r"""A generic search for a parameter set such that all problem instances generated by ``parameter_problem`` for the given paramter set satisfy a given bit security level ``sec``.

    The search starts with the parameter set ``initial_parameters``. At the end of each iteration, new parameter sets are generated using ``next_parameters`` and sorted into an ordered list of parameter sets according to ``parameter_cost``. If no ``parameter_cost``-function is specified, :py:func:`lattice_parameter_estimation.param_search.unit_cost` is used. In an iteration, the first parameter set in the list is retrieved and a set of problem instances is generated for the given parameter set according to ``parameter_problem``. Then, a cost estimation algorithm is executed on all generated problem instances. If one of the cost estimation algorithms specified in ``config`` returns a cost lower than :math:`2^\text{sec}`, the cost estimation for the given parameter set is terminated early. If all algorithms return cost higher than :math:`2^\text{sec}`, the problem instances in the set are secure and the current parameter set is returned, in addition to the aggregate cost results.


    :param sec: required bit security level
    :param initial_parameters: initial parameter set of search. Must be tuple or scalar. If it is a scalar, set ``scalar_parameters`` to ``True``.
    :param next_parameters: generator function yielding (possibly multiple) new parameter sets with previous parameter set as input. Note that duplicate detection does not work if paramter_cost(*parameter_set) > parameter_cost(next(next_parameters(*parameter_set))). It is recommended to yield parameter sets in some ascending order. The function must yield a tuple or a scalar. If a scalar is yielded, set ``scalar_parameters`` to ``True``.
    :param parameter_cost: cost function of a parameter set used in the scheme to determine to order currently queued parameter sets. Use lib.unit_cost if sequence does not matter
    :param parameter_problem: function yielding possibly multiple problem instances with a paramter set as input
    :param config: configuration, instance of :py:class:`lattice_parameter_estimation.algorithms.Configuration`
    :param scalar_parameters: True if parameter sets are scalars, else parameter sets must be tuples.

    :returns: dict with entries ``"parameters"`` (secure paramter set) and ``"result"`` (instance of :py:class:`lattice_parameter_estimation.problem.AggregateEstimationResult` containing cost estimates and results from all estimation algorithms).
    """
    start = time.time()
    parameters = [initial_parameters]
    if scalar_parameters:
        costs = [parameter_cost(initial_parameters)]
    else:
        costs = [parameter_cost(*initial_parameters)]

    def insort(parameter_set):
        if scalar_parameters:
            cost = parameter_cost(parameter_set)
        else:
            cost = parameter_cost(*parameter_set)

        i = bisect.bisect_right(costs, cost)

        # only insert if not duplicate
        j = i - 1
        while j >= 0 and costs[j] == cost:
            if parameters[j] == parameter_set:
                return  # duplicate
            j -= 1

        costs.insert(i, cost)
        parameters.insert(i, parameter_set)

    ignore_all_failed = False
    while parameters:
        current_parameter_set = parameters.pop(0)
        cost = costs.pop(0)

        logger.info(SEPARATOR)
        logger.info(
            f"Checking next parameter set: {current_parameter_set} with cost {cost}"
        )

        try:
            if scalar_parameters:
                results = problem.estimate(
                    parameter_problems=parameter_problem(current_parameter_set),
                    config=config,
                    sec=sec,
                )
            else:
                results = problem.estimate(
                    parameter_problems=parameter_problem(*current_parameter_set),
                    config=config,
                    sec=sec,
                )
            if results.is_secure():
                duration = time.time() - start
                logger.info(SEPARATOR)
                logger.info(
                    f"Generic search successful (took {duration}s). Estimated security level is > {results.lowest_sec}."
                )
                logger.info(f"Parameters: {current_parameter_set}")
                return {"parameters": current_parameter_set, "result": results}
        except problem.EmptyProblem:
            pass
        except TimeoutError as e:
            logger.error(e)
        except problem.AllFailedError:
            if not ignore_all_failed:
                print(SEPARATOR)
                input(
                    "All algorithms failed. Press Enter to ignore (from now on) and continue..."
                )
            ignore_all_failed = True
        except ValueError as e:
            raise e

        if scalar_parameters:
            for parameter_set in next_parameters(current_parameter_set):
                insort(parameter_set)
        else:
            for parameter_set in next_parameters(*current_parameter_set):
                insort(parameter_set)

        # Check RAM
        perc_RAM = psutil.virtual_memory()[2]
        if perc_RAM > 95:
            logger.critical(f"RAM almost full {perc_RAM}. Terminating...")
            break
        else:
            logger.debug(f"{perc_RAM} % of RAM used.")
